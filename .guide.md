# CodableMacro 新功能實作指南

## 一、執行摘要

本指南詳細說明三個高優先級功能的實作規範：

### 高優先級（必須實作）
1. **@CodingIgnored 屬性忽略機制** - 讓開發者能控制哪些屬性不參與序列化
2. **Public 可見性支援** - 自動偵測並產生對應的 public 修飾詞
3. **預設值處理** - Optional 屬性解碼失敗時使用預設值

### 實作順序
功能 1 → 功能 2 → 功能 4

### 預計工時
9-13 小時

---

## 二、功能 1：@CodingIgnored 屬性忽略機制

### 需求說明

開發者需要能夠：
- 使用 `@CodingIgnored` 標記不參與編碼/解碼的屬性
- 自動忽略 computed properties（無 storage 的屬性）
- 自動忽略函數定義
- 避免 macro 嘗試處理這些屬性導致編譯錯誤

### 使用範例

```swift
@Codable
struct ToolResultContent {
    let toolUseId: String
    let content: String

    @CodingIgnored  // 明確標記忽略
    var processedContent: String = ""

    // 自動忽略（computed property）
    var hasLineNumbers: Bool {
        content.contains("\n")
    }

    // 自動忽略（函數）
    func parseLines() -> [String] {
        content.split(separator: "\n").map(String.init)
    }
}
```

### 技術實作

#### 1. 新增 CodingIgnoredMacro.swift

```swift
import SwiftCompilerPlugin
import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftSyntaxMacros

/// @CodingIgnored macro 用於標記不參與 Codable 編碼/解碼的屬性
public struct CodingIgnoredMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        // PeerMacro 不生成程式碼，只用於標記
        return []
    }
}
```

#### 2. 修改 CodableMacro.swift 定義

在 `Sources/CodableMacro/CodableMacro.swift` 新增：

```swift
@attached(peer)
public macro CodingIgnored() = #externalMacro(module: "CodableMacroMacros", type: "CodingIgnoredMacro")
```

#### 3. 修改 Property 結構

在 `Sources/CodableMacroMacros/CodableMacro.swift` 中修改：

```swift
struct Property {
    let name: String
    let type: String
    let isOptional: Bool
    let isLet: Bool
    let customKey: String?
    let isIgnored: Bool  // 新增欄位
}
```

#### 4. 修改 extractProperties 函數

```swift
static func extractProperties(from declaration: some DeclGroupSyntax) throws -> [Property] {
    var properties: [Property] = []

    for member in declaration.memberBlock.members {
        guard let variableDecl = member.decl.as(VariableDeclSyntax.self) else {
            continue  // 跳過非變數宣告（如函數）
        }

        for binding in variableDecl.bindings {
            guard let identifier = binding.pattern.as(IdentifierPatternSyntax.self) else {
                continue
            }

            // 檢查是否為 computed property（有 accessor block 但無 initializer）
            let isComputedProperty = binding.accessorBlock != nil && binding.initializer == nil
            if isComputedProperty {
                continue  // 自動忽略 computed properties
            }

            guard let typeAnnotation = binding.typeAnnotation else {
                continue
            }

            let propertyName = identifier.identifier.text
            let propertyType = typeAnnotation.type.trimmedDescription
            let isOptional = propertyType.hasSuffix("?")
            let isLet = variableDecl.bindingSpecifier.text == "let"

            // 檢查是否有 @CodingIgnored attribute
            var isIgnored = false
            var customKey: String? = nil

            for attribute in variableDecl.attributes {
                guard case let .attribute(attr) = attribute,
                      let identifierType = attr.attributeName.as(IdentifierTypeSyntax.self) else {
                    continue
                }

                let attributeName = identifierType.name.text

                if attributeName == "CodingIgnored" {
                    isIgnored = true
                }

                if attributeName == "CodingKey" {
                    if let argument = attr.arguments?.as(LabeledExprListSyntax.self)?.first,
                       let stringLiteral = argument.expression.as(StringLiteralExprSyntax.self),
                       let segment = stringLiteral.segments.first?.as(StringSegmentSyntax.self) {
                        customKey = segment.content.text
                    }
                }
            }

            properties.append(Property(
                name: propertyName,
                type: propertyType,
                isOptional: isOptional,
                isLet: isLet,
                customKey: customKey,
                isIgnored: isIgnored
            ))
        }
    }

    // 過濾掉被標記為忽略的屬性
    return properties.filter { !$0.isIgnored }
}
```

#### 5. 註冊到 CodableMacroPlugin

在 `Sources/CodableMacroMacros/CodableMacroPlugin.swift` 修改：

```swift
@main
struct CodableMacroPlugin: CompilerPlugin {
    let providingMacros: [Macro.Type] = [
        CodableMacro.self,
        CodingKeyMacro.self,
        CodingIgnoredMacro.self  // 新增
    ]
}
```

### 測試案例（CodingIgnoredTests.swift）

共 8 個測試：基本忽略、多屬性忽略、computed property 自動忽略、混合測試、Optional 忽略、所有屬性被忽略、Class 測試、與 @CodingKey 混合使用。

### 驗收標準

- ✅ @CodingIgnored 標記的屬性不出現在 CodingKeys
- ✅ 被忽略的屬性不參與編碼/解碼
- ✅ Computed properties 自動被忽略
- ✅ 8 個測試全部通過
- ✅ `swift build` 成功

---

## 三、功能 2：Public 可見性支援

### 需求說明

當型別宣告為 `public` 時，生成的 Codable 實作也需要是 `public`，否則會編譯錯誤。

### 使用範例

```swift
@Codable
public struct ApprovalResponseMessage {
    public let type: String
    public let content: String
}

// 應產生：
// public enum CodingKeys: String, CodingKey { ... }
// public init(from decoder: Decoder) throws { ... }
// public func encode(to encoder: Encoder) throws { ... }
```

### 技術實作

#### 1. 新增 isPublicType 輔助函數

```swift
extension CodableMacro {
    // MARK: - 可見性檢查

    /// 檢查型別是否為 public
    static func isPublicType(_ declaration: some DeclGroupSyntax) -> Bool {
        for modifier in declaration.modifiers {
            if modifier.name.text == "public" {
                return true
            }
        }
        return false
    }
}
```

#### 2. 修改所有生成函數簽章

所有生成函數新增 `isPublic: Bool` 參數，並在模板中加入 `\(publicModifier)` 修飾詞：

```swift
let publicModifier = isPublic ? "public " : ""
```

影響範圍：
- `generateCodingKeys`
- `generateInitFromDecoder`
- `generateInitFromDecoderForClass`
- `generateEncodeMethod`
- `generateFromDictMethod`
- `generateToDictMethod`
- `generateFromDictArrayMethod`
- `generateToDictArrayMethod`
- `handleStruct`、`handleClass`
- Enum 相關函數

### 測試案例（PublicVisibilityTests.swift）

共 5 個測試：Public struct、Public class、Internal struct、Public struct with Optional、Public 與 @CodingKey 混合。

### 驗收標準

- ✅ Public struct 產生 public 修飾詞
- ✅ Public class 產生 `public required init`
- ✅ Internal 型別維持原行為
- ✅ 5 個測試全部通過
- ✅ `swift build` 成功

---

## 四、功能 4：預設值處理

### 需求說明

Optional 屬性可以宣告預設值，當 JSON 解碼缺少該欄位時使用預設值。

### 使用範例

```swift
@Codable
struct LocalOutputContent {
    let stdout: String? = nil
    let stderr: String? = nil
    let exitCode: Int? = 0
}

// JSON: {"stdout": "hello"}
// 解碼結果: LocalOutputContent(stdout: "hello", stderr: nil, exitCode: 0)
```

### 技術實作

#### 1. 修改 Property 結構

```swift
struct Property {
    let name: String
    let type: String
    let isOptional: Bool
    let isLet: Bool
    let customKey: String?
    let isIgnored: Bool
    let defaultValue: String?  // 新增欄位
}
```

#### 2. 修改 extractProperties 提取預設值

```swift
// 提取預設值
var defaultValue: String? = nil
if let initializer = binding.initializer {
    defaultValue = initializer.value.trimmedDescription
}

properties.append(Property(
    // ...
    defaultValue: defaultValue
))
```

#### 3. 修改 generateInitFromDecoder

```swift
for property in properties {
    let optionalType = property.type.replacingOccurrences(of: "?", with: "")

    if property.isOptional {
        if let defaultValue = property.defaultValue {
            // 有預設值：使用 ?? defaultValue
            codeLines.append("self.\(property.name) = try container.decodeIfPresent(\(optionalType).self, forKey: .\(property.name)) ?? \(defaultValue)")
        } else {
            // 無預設值：原邏輯
            codeLines.append("self.\(property.name) = try container.decodeIfPresent(\(optionalType).self, forKey: .\(property.name))")
        }
    } else {
        codeLines.append("self.\(property.name) = try container.decode(\(property.type).self, forKey: .\(property.name))")
    }
}
```

#### 4. 修改 generateInitFromDecoderForClass

同樣的邏輯應用到 class 的 init。

### 測試案例

- **DefaultValueTests.swift**：6 個 macro 測試
- **RuntimeDefaultValueTests.swift**：3 個 runtime 測試

### 驗收標準

- ✅ Optional 屬性支援預設值宣告
- ✅ 解碼缺少欄位時使用預設值
- ✅ 解碼有欄位值時覆蓋預設值
- ✅ 6 個 macro 測試通過
- ✅ 3 個 runtime 測試通過
- ✅ `swift build` 成功

---

## 五、檔案變更清單

### 新建檔案（5 個）
- `Sources/CodableMacroMacros/CodingIgnoredMacro.swift`
- `Tests/CodableMacroTests/CodingIgnoredTests.swift`
- `Tests/CodableMacroTests/PublicVisibilityTests.swift`
- `Tests/CodableMacroTests/DefaultValueTests.swift`
- `Tests/CodableMacroTests/RuntimeDefaultValueTests.swift`

### 修改檔案（4 個）
- `Sources/CodableMacro/CodableMacro.swift`
- `Sources/CodableMacroMacros/CodableMacro.swift`
- `Sources/CodableMacroMacros/CodableMacroPlugin.swift`
- `README.md`

---

## 六、執行檢查清單

### 功能 1 完成檢查
- [ ] CodingIgnoredMacro.swift 實作完成
- [ ] CodableMacro.swift 定義更新
- [ ] Property 結構新增 isIgnored 欄位
- [ ] extractProperties 實作忽略邏輯
- [ ] Plugin 註冊完成
- [ ] 8 個測試全部通過
- [ ] `swift test` 無錯誤
- [ ] `swift build` 無錯誤

### 功能 2 完成檢查
- [ ] isPublicType 函數實作完成
- [ ] 所有生成函數簽章修改完成
- [ ] 5 個測試全部通過
- [ ] `swift test` 無錯誤
- [ ] `swift build` 無錯誤

### 功能 4 完成檢查
- [ ] Property 結構新增 defaultValue 欄位
- [ ] extractProperties 提取預設值完成
- [ ] generateInitFromDecoder 支援預設值
- [ ] generateInitFromDecoderForClass 支援預設值
- [ ] 9 個測試通過（6 macro + 3 runtime）
- [ ] `swift test` 無錯誤
- [ ] `swift build` 無錯誤

### 最終檢查
- [ ] README.md 更新完成
- [ ] 所有現有測試持續通過
- [ ] 完整測試套件執行成功
- [ ] `swift build` 最終執行成功

---

## 七、風險與注意事項

### 已知限制

1. **預設值只支援 Optional 型別**
2. **Public 屬性可見性不強制檢查**
3. **Computed property 偵測依賴語法樹結構**

### 除錯建議

- 檢查 expandedSource 是否包含完整展開結果
- 確認縮排和換行符號一致
- 使用 `swift test --verbose` 查看詳細錯誤

---

## 八、完成標準

- ✅ 所有新測試通過（22 個測試：8 + 5 + 9）
- ✅ 所有現有測試持續通過
- ✅ `swift build` 零錯誤零警告
- ✅ README 文件完整更新
- ✅ 程式碼符合專案風格規範
- ✅ 無回歸問題

預計完成時間：9-13 小時
